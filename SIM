#!/usr/bin/python3

#NOTE: RUN FROM COMMAND LINE AS:
#python3 SIM 10 sim-traces-0-1/uniform-0-1-00.dat sim-traces-0-1/uniform-0-1-01.dat sim-traces-0-1/uniform-0-1-02.dat

#
# Stacia Near and Chin ______
# Simulation assignment
# Crosswalk sim
#

import sys
import os
from enum import Enum

#importing of the class files
from classes import safety_signals
from classes import ped
from classes import auto
from classes import event

import argparse
from classes.event import event_type
try:
    import Queue as Q  # ver. < 3.0
except ImportError:
    import queue as Q

#statistical imports
import math
from random import expovariate # exponenial(lamb)
from random import normalvariate #(mu, sigma)
from random import uniform
from statistics import mean
from statistics import median
#mport matplotlib.pyplot as plt
#import numpy as np


#Global declarations

#TODO: priority queues: notation is "put" and "get"
event_list = Q.PriorityQueue()
peds_at_crosswalk = Q.PriorityQueue()
ped_list = []
auto_list = []
red_light_times = [] #times when red light turned on

n = 0
t = 0
autoTracefile = ""
pedTracefile = ""
buttonTracefile = ""
lineInAutoTrace = 0
lineInPedTrace= 0
lineInButtonTrace = 0
pedNum = 1
autoNum = 1
#eventType = event_type

#static
rp = 3 #ped arrival rate in one direction
ra = 4 #auto arrival rate



def main():
    parseArgs()
    run()
    
#-----------------------------------------------------------------------------------
#Main simulation loop      
#-----------------------------------------------------------------------------------

def run():
    #Use globals
    #TODO: generate n aumobiles
    #TODO: generate n pedestrians
    global n
    global t
    global event_list
    global peds_at_crosswalk
    global ped_list
    global auto_list
    global pedNum
    global autoNum
    global red_light_times
    
    #initialize sim variables
    t = 0 #sim_time
    
    #To begin, we will spawn the first auto and ped
    #when each arrival is processed, it spawns the next arrival of the same type
    spawnAuto()
    spawnPed()

    



    
    
    

    
    testRandomValues()
    
    #while not event_list.empty(): #event_list non empty
    #    e = event_list.pop(0)
    
#-----------------------------------------------------------------------------------
#End Main simulation
#-----------------------------------------------------------------------------------
    

def spawnAuto():
    global event_list
    global auto_list
    global autoNum
    
    auto_interarrival = getNextAutoInterarrival()
    auto_arrival = t + auto_interarrival
    velocity = getNextAutoSpeed()
    newAuto = auto.auto(auto_arrival, velocity, autoNum)
    
    event_list._put(event.event(auto_arrival, event.event_type.AUTO_ARRIVAL, autoNum))
    auto_list.append(newAuto)
    
    autoNum += 1
    
def spawnPed():
    global event_list
    global peds_at_crosswalk
    global ped_list
    global pedNum
    
    ped_interarrival = getNextPedInterarrival()
    ped_arrival = t + ped_interarrival
    velocity = getNextPedSpeed()
    newPed = ped.ped(ped_arrival, velocity, pedNum)

    event_list._put(event.event(ped_arrival, event.event_type.PED_ARRIVAL, pedNum))
    ped_list.append(newPed)
    
    pedNum += 1
    
def exitAuto():
    pass
def exitPed():
    pass


def getNextAutoInterarrival():
    u = readNextUniformInTrace(traceType.AUTO)
    u = float(u)
    return -2*ra*math.log(1.0 - u)

def getNextPedInterarrival():
    u = readNextUniformInTrace(traceType.PED)
    u = float(u)
    return -2*rp*math.log(1.0 - u)

#Uniform(25,35) 
def getNextAutoSpeed():
    u = readNextUniformInTrace(traceType.AUTO)
    u = float(u)
    a = 25
    b = 35
    return a + u * (b - a)
    
#Uniform(2.6,4.1)
def getNextPedSpeed():
    u = readNextUniformInTrace(traceType.PED)
    u = float(u)
    a = 2.6
    b = 4.1
    return a + u * (b - a)

def getNext_ButtonTracefile_UniformRand():
    #TODO CONVERT TO PROBABILITY VALUE CORRECTLY
    #THIS WILL ALWAYS RETURN UNIFORM 0,1
    #YOU WILL NEED TO INTREPRET IT BASED ON STATE OF CROSSWALK
    u = readNextUniformInTrace(traceType.BUTTON)
    u = float(u)
    return u

class traceType(Enum):
    AUTO = 0
    PED = 1
    BUTTON = 2

#DO NOT CALL THIS DIRECTLY
#call using the above methods to get random values
def readNextUniformInTrace(traceCurrent):
    if not isinstance(traceCurrent, traceType):
        raise TypeError('Must be a trace type enum type')
    
    uniformRand = 0
    global autoTracefile
    global pedTracefile
    global buttonTracefile
    global lineInAutoTrace
    global lineInPedTrace
    global lineInButtonTrace
    
    if traceCurrent == traceType.AUTO:
        uniformRand = readFile(autoTracefile, lineInAutoTrace)
        lineInAutoTrace+= 1
    elif traceCurrent == traceType.PED:
        uniformRand = readFile(pedTracefile, lineInPedTrace)
        lineInPedTrace+= 1
    elif traceCurrent == traceType.BUTTON:
        uniformRand = readFile(buttonTracefile, lineInButtonTrace)
        lineInButtonTrace+= 1
    
    if (uniformRand == 0):
        print("Uniform value not returned")
        sys.exit(1)
    
    return uniformRand
        

def parseArgs():
    #TODO: must handle any problems with  argument values and exit with descriptive non zero
    #use globals!
    global autoTracefile
    global pedTracefile
    global buttonTracefile
    
    #note that "SIM" counts as an arg
    if len(sys.argv) != 5 :
        print('Number of arguments:', len(sys.argv), 'arguments.')
        print('Argument List:', str(sys.argv))
        print("Usage: python3 SIM [1 2 3 4]\n \
        1. N, the number of automobile and pedestrian arrivals to generate (N>0).\n \
        2. A Uniform(0,1) trace file of random values for automobile arrivals and speeds.\n \
        3. A Uniform(0,1) trace file of random values for pedestrian arrivals and speeds.\n \
        4. A Uniform(0,1) trace file of random values for resolving crosswalk button presses.\n")
        sys.exit (1)

    n = int(sys.argv[1])
    
    if (n <= 0):
        print("Need positive number of auto/pedestrian arrivals.")
        sys.exit(1)
    
    autoTracefile = sys.argv[2] #Uniform(0,1)
    pedTracefile = sys.argv[3] #Uniform(0,1)
    buttonTracefile = sys.argv[4] #Uniform(0,1)
    
    readFile(autoTracefile, 0)
    readFile(pedTracefile, 0)
    readFile(buttonTracefile, 0)
    
    
def readFile(filename, lineInFile):
    #filehandle = open(filename)
    #print(filehandle.read())
    #filehandle.close()
    
    relativeFilename = filename;
    fileDir = os.path.dirname(os.path.realpath('__file__'))
    filename = os.path.join(fileDir, filename)
    
    try:
        #i starts at 0
        with open(filename) as fp:
            for i, line in enumerate(fp):
                if i == lineInFile:
                    #print(line)
                    break
        
        
        if len(line.strip()) == 0 :
            raise Exception('File ended prematurely:', relativeFilename)
        
        return line

    except IOError:
        print("Could not read file:", relativeFilename)
        sys.exit(1)
    except Exception as err:
        print(err.args[0], err.args[1])
        sys.exit(1)
    
    
def testRandomValues():

    numTests = 5
    
    print("Auto arrival test")
    for i in range (0,numTests):
        print(getNextAutoInterarrival())
    
    #25 to 35  
    print("\n\nAuto speed test")
    for i in range (0,numTests):
        print(getNextAutoSpeed())

    print("\n\nPed arrival test")
    for i in range (0,numTests):
        print(getNextPedInterarrival())
        
    #Uniform(2.6,4.1)
    print("\n\nPed speed test")
    for i in range (0,numTests):
        print(getNextPedSpeed())

    print("\n\nUniform button press values")
    for i in range (0,numTests):
        print(getNext_ButtonTracefile_UniformRand())
    

if __name__ == "__main__":
    main()

    
