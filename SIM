#!/usr/bin/python3

#NOTE: RUN FROM COMMAND LINE AS:
#python3 SIM 10 sim-traces-0-1/uniform-0-1-00.dat sim-traces-0-1/uniform-0-1-01.dat sim-traces-0-1/uniform-0-1-02.dat

#
# Stacia Near and Chin Isaac-Heslop
# Simulation assignment
# Crosswalk sim
#

import sys
import os
from enum import Enum

#importing of the class files
from classes import safety_signals as s
from classes import ped
from classes import auto
from classes import event

import argparse
from classes.event import event_type
try:
    import Queue as Q  # ver. < 3.0
except ImportError:
    import queue as Q

#statistical imports
import math
from random import expovariate # exponenial(lamb)
from random import normalvariate #(mu, sigma)
from random import uniform
from statistics import mean
from statistics import median
#mport matplotlib.pyplot as plt
#import numpy as np


#Global declarations

#TODO: priority queues: notation is "put" and "get"
event_list = Q.PriorityQueue()
s.event_list = event_list
peds_at_crosswalk = Q.PriorityQueue()
ped_list = []
auto_list = []
red_light_times = [] #times when red light turned on

n = 0
t = 0
autoTracefile = ""
pedTracefile = ""
buttonTracefile = ""
lineInAutoTrace = 0
lineInPedTrace= 0
lineInButtonTrace = 0
pedNum = 1
autoNum = 1
#eventType = event_type

#static
rp = 3 #ped arrival rate in one direction
ra = 4 #auto arrival rate



def main():
    parseArgs()
    run()
    
#-----------------------------------------------------------------------------------
#Main simulation loop      
#-----------------------------------------------------------------------------------

def run():
    #Use globals
    ## these variables are all used in the same function main so no need to describe as global since not used elsewhere without being passed
    global n
    global t
    global event_list
    global peds_at_crosswalk
    global ped_list
    global auto_list
    global pedNum
    global autoNum
    global red_light_times
    
    #initialize sim variables
    t = 0 #sim_time
    safetySignal = s.safety_signals( s.crosswalksignal.GREEN_GO_YELLOW_ON_PRESS )
    
    #TEST CODE    
    testRandomValues()
    
    #To begin, we will spawn the first auto and ped
    #when each arrival is processed, it spawns the next arrival of the same type
    spawnAuto()
    spawnPed()
    
    while not event_list.empty(): #event_list non empty
        e = event_list.get() #remove current from event list
        
        t = e.time
        #print(t)
        
        if e.type == event.event_type.AUTO_ARRIVAL:
            #if auto arrival, spawn the next auto
            #and schedule the exit of the current auto
            spawnAuto()
            scheduleExitAuto(e.id)
            
        elif e.type == event.event_type.PED_ARRIVAL:
            spawnPed()
            #scheduleExitPed(e.id)
            s.safety_signals.button_press( safetySignal )            

        elif e.type == event.event_type.PED_AT_BUTTON:
            s.safety_signals.ped_at_button( safetySignal )

        elif e.type == event.event_type.PED_IMPATIENT:
           s.safety_signals.button_press( safetySignal )

        elif e.type == event.event_type.GREEN_EXPIRES:
            s.safety_signals.green_expires( safetySignal )

        elif e.type == event.event_type.YELLOW_EXPIRES:
            s.safety_signals.yellow_expires( safetySignal )

        elif e.type == event.event_type.RED_EXPIRES:
            s.safety_signals.red_expires( safetySignal )

        elif e.type == event.event_type.AUTO_EXIT:
            
            exitAuto(e.id)
            
        elif e.type == event.event_type.PED_EXIT:
            exitPed(e.id)
            
    
#-----------------------------------------------------------------------------------
#End Main simulation
#-----------------------------------------------------------------------------------
    

def spawnAuto():
    global event_list
    global auto_list
    global autoNum
    
    #no spawns if exceed number
    if (autoNum > n): 
        return
    
    auto_interarrival = getNextAutoInterarrival()
    auto_arrival = t + auto_interarrival
    velocity = getNextAutoSpeed()
    newAuto = auto.auto(auto_arrival, velocity, autoNum)
    
    event_list._put(event.event(auto_arrival, event.event_type.AUTO_ARRIVAL, autoNum))
    auto_list.append(newAuto)
    
    autoNum += 1
    
    print(str(newAuto))
    
def spawnPed():
    global event_list
    global peds_at_crosswalk
    global ped_list
    global pedNum
    
    if (pedNum > n): 
        return
    
    ped_interarrival = getNextPedInterarrival()
    ped_arrival = t + ped_interarrival
    velocity = getNextPedSpeed()
    newPed = ped.ped(ped_arrival, velocity, pedNum)

    event_list._put(event.event(ped_arrival, event.event_type.PED_ARRIVAL, pedNum))
    ped_list.append(newPed)
    
    pedNum += 1
    
def scheduleExitAuto(id):
    global event_list

    for a in auto_list:
        if a.id == id:
            #if correct id, keep as "a"
            #TODO these should all be before the break
            event_list._put(event.event(a.exit_time_if_no_delay(), event.event_type.AUTO_EXIT, a.id))
            break
    
    
def scheduleExitPed(id):
    global event_list

    for p in ped_list:
        if p.id == id:
            #TODO make it actual exit time not exit time with no delay
            event_list.put( event.event( p.exit_time_if_no_delay(), event.event_type.PED_EXIT, p.id ) )
            break
    
def exitAuto(id):
    global auto_list
    
    for a in auto_list:
        if a.id == id:
            auto_list.remove(a) #if correct id, remove from list of autos
            break
    
    #CALCULATE DELAY
    a.calculate_auto_delay()

def exitPed(id):
    global ped_list
    for p in ped_list:
        if p.id == id:
            p.calculate_ped_delay()
            ped_list.remove( p )
            break

def getNextAutoInterarrival():
    u = readNextUniformInTrace(traceType.AUTO)
    u = float(u)
    return -2*ra*math.log(1.0 - u)

def getNextPedInterarrival():
    u = readNextUniformInTrace(traceType.PED)
    u = float(u)
    return -2*rp*math.log(1.0 - u)

#Uniform(25,35) 
def getNextAutoSpeed():
    u = readNextUniformInTrace(traceType.AUTO)
    u = float(u)
    a = 25
    b = 35
    return a + u * (b - a)
    
#Uniform(2.6,4.1)
def getNextPedSpeed():
    u = readNextUniformInTrace(traceType.PED)
    u = float(u)
    a = 2.6
    b = 4.1
    return a + u * (b - a)

def getNext_ButtonTracefile_UniformRand():
    #TODO CONVERT TO PROBABILITY VALUE CORRECTLY
    #THIS WILL ALWAYS RETURN UNIFORM 0,1
    #YOU WILL NEED TO INTREPRET IT BASED ON STATE OF CROSSWALK
    u = readNextUniformInTrace(traceType.BUTTON)
    u = float(u)
    return u

class traceType(Enum):
    AUTO = 0
    PED = 1
    BUTTON = 2

#DO NOT CALL THIS DIRECTLY
#call using the above methods to get random values
def readNextUniformInTrace(traceCurrent):
    if not isinstance(traceCurrent, traceType):
        raise TypeError('Must be a trace type enum type')
    
    uniformRand = 0
    global autoTracefile
    global pedTracefile
    global buttonTracefile
    global lineInAutoTrace
    global lineInPedTrace
    global lineInButtonTrace
    
    if traceCurrent == traceType.AUTO:
        uniformRand = readFile(autoTracefile, lineInAutoTrace)
        lineInAutoTrace+= 1
    elif traceCurrent == traceType.PED:
        uniformRand = readFile(pedTracefile, lineInPedTrace)
        lineInPedTrace+= 1
    elif traceCurrent == traceType.BUTTON:
        uniformRand = readFile(buttonTracefile, lineInButtonTrace)
        lineInButtonTrace+= 1
    
    if (uniformRand == 0):
        print("Uniform value not returned")
        sys.exit(1)
    
    return uniformRand
        

def parseArgs():
    #TODO: must handle any problems with  argument values and exit with descriptive non zero
    #use globals!
    global n
    global autoTracefile
    global pedTracefile
    global buttonTracefile
    
    #note that "SIM" counts as an arg
    if len(sys.argv) != 5 :
        print('Number of arguments:', len(sys.argv), 'arguments.')
        print('Argument List:', str(sys.argv))
        print("Usage: python3 SIM [1 2 3 4]\n \
        1. N, the number of automobile and pedestrian arrivals to generate (N>0).\n \
        2. A Uniform(0,1) trace file of random values for automobile arrivals and speeds.\n \
        3. A Uniform(0,1) trace file of random values for pedestrian arrivals and speeds.\n \
        4. A Uniform(0,1) trace file of random values for resolving crosswalk button presses.\n")
        sys.exit (1)

    n = int(sys.argv[1])
    
    if (n <= 0):
        print("Need positive number of auto/pedestrian arrivals.")
        sys.exit(1)
    
    autoTracefile = sys.argv[2] #Uniform(0,1)
    pedTracefile = sys.argv[3] #Uniform(0,1)
    buttonTracefile = sys.argv[4] #Uniform(0,1)
    
    readFile(autoTracefile, 0)
    readFile(pedTracefile, 0)
    readFile(buttonTracefile, 0)
    
    
def readFile(filename, lineInFile):
    #filehandle = open(filename)
    #print(filehandle.read())
    #filehandle.close()
    
    relativeFilename = filename;
    fileDir = os.path.dirname(os.path.realpath('__file__'))
    filename = os.path.join(fileDir, filename)
    
    try:
        #i starts at 0
        with open(filename) as fp:
            for i, line in enumerate(fp):
                if i == lineInFile:
                    #print(line)
                    break
        
        
        if len(line.strip()) == 0 :
            raise Exception('File ended prematurely:', relativeFilename)
        
        return line

    except IOError:
        print("Could not read file:", relativeFilename)
        sys.exit(1)
    except Exception as err:
        print(err.args[0], err.args[1])
        sys.exit(1)
    
    
def testRandomValues():

    numTests = 5
    
    print("Auto test")
    for i in range (0,numTests*2):
        if i % 2 == 0: #even 
            print('Interarrival', getNextAutoInterarrival(), end='  ')
        else: #odd
            print('Speed', getNextAutoSpeed())

    print("\nPed test")
    for i in range (0,numTests*2):
        if i % 2 == 0: #even 
            print('Interarrival', getNextPedInterarrival(), end='  '),
        else: #odd
            print('Speed', getNextPedSpeed())

    print("\nUniform button press values")
    for i in range (0,numTests):
        print(getNext_ButtonTracefile_UniformRand())
        
    print("\nReturning to beginning of input files.\n\n")
    
    #Refresh bookmarks
    global lineInAutoTrace
    global lineInPedTrace
    global lineInButtonTrace
    lineInAutoTrace  =0
    lineInPedTrace   =0
    lineInButtonTrace=0
    
if __name__ == "__main__":
    main()

    
